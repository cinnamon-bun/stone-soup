// Generated by dts-bundle-generator v5.9.0

export declare type AuthorAddress = string;
export declare type WorkspaceAddress = string;
export declare type Path = string;
export declare type Signature = string;
export declare type Timestamp = number;
export declare type LocalIndex = number;
export interface Doc {
	format: string;
	author: AuthorAddress;
	content: string;
	contentHash: string;
	deleteAfter: number | null;
	path: Path;
	signature: Signature;
	timestamp: Timestamp;
	workspace: WorkspaceAddress;
	_localIndex?: LocalIndex;
}
export interface QueryFilter {
	path?: Path;
	pathStartsWith?: string;
	pathEndsWith?: string;
	author?: AuthorAddress;
	timestamp?: Timestamp;
	timestampGt?: Timestamp;
	timestampLt?: Timestamp;
	contentLength?: number;
	contentLengthGt?: number;
	contentLengthLt?: number;
}
export declare type HistoryMode = "latest" | "all";
export interface Query {
	historyMode?: HistoryMode;
	orderBy?: "path ASC" | "path DESC" | "localIndex ASC" | "localIndex DESC";
	startAfter?: {
		localIndex?: number;
		path?: string;
	};
	filter?: QueryFilter;
	limit?: number;
}
export interface IStorageAsyncConfigStorage {
	getConfig(key: string): Promise<string | undefined>;
	setConfig(key: string, value: string): Promise<void>;
	listConfigKeys(): Promise<string[]>;
	deleteConfig(key: string): Promise<boolean>;
}
/**
 * A storageDriver provides low-level access to actual storage and is used by
 * IStorageAsync to actually load and save data.
 * StorageDrivers are not meant to be used directly by users; let the IStorageAsync
 * talk to it for you.
 */
export interface IStorageDriverAsync extends IStorageAsyncConfigStorage {
	workspace: WorkspaceAddress;
	isClosed(): boolean;
	/**
	 * Close the storageDriver.
	 * The Storage will call this.
	 * You cannot call close() if the storage is already closed (it will throw a StorageIsClosedError).
	 * If erase, actually delete and forget data locally.
	 * Erase defaults to false if not provided.
	 */
	close(erase: boolean): Promise<void>;
	getMaxLocalIndex(): number;
	queryDocs(query: Query): Promise<Doc[]>;
	upsert(doc: Doc): Promise<Doc>;
}
declare class StorageDriverAsyncMemory implements IStorageDriverAsync {
	workspace: WorkspaceAddress;
	_maxLocalIndex: LocalIndex;
	_isClosed: boolean;
	_configKv: Record<string, string>;
	docByPathAndAuthor: Map<string, Doc>;
	docsByPathNewestFirst: Map<Path, Doc[]>;
	constructor(workspace: WorkspaceAddress);
	isClosed(): boolean;
	close(erase: boolean): Promise<void>;
	getConfig(key: string): Promise<string | undefined>;
	setConfig(key: string, value: string): Promise<void>;
	listConfigKeys(): Promise<string[]>;
	deleteConfig(key: string): Promise<boolean>;
	getMaxLocalIndex(): number;
	_getAllDocs(): Promise<Doc[]>;
	_getLatestDocs(): Promise<Doc[]>;
	queryDocs(queryToClean: Query): Promise<Doc[]>;
	upsert(doc: Doc): Promise<Doc>;
}
export declare class StorageDriverLocalStorage extends StorageDriverAsyncMemory {
	_localStorageKeyConfig: string;
	_localStorageKeyDocs: string;
	constructor(workspace: WorkspaceAddress);
	close(erase: boolean): Promise<void>;
	_getConfigSync(key: string): string | undefined;
	_setConfigSync(key: string, value: string): void;
	_listConfigKeysSync(): string[];
	_deleteConfigSync(key: string): boolean;
	getConfig(key: string): Promise<string | undefined>;
	setConfig(key: string, value: string): Promise<void>;
	listConfigKeys(): Promise<string[]>;
	deleteConfig(key: string): Promise<boolean>;
	upsert(doc: Doc): Promise<Doc>;
}

export {};
